level07@OverRide:~$ objdump -R level07

level07:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
08049ff0 R_386_GLOB_DAT    __gmon_start__
0804a040 R_386_COPY        stdin
0804a060 R_386_COPY        stdout
0804a000 R_386_JUMP_SLOT   printf
0804a004 R_386_JUMP_SLOT   fflush                     # ffluch "cleanse" env variable, making us unable to store shellcode there
0804a008 R_386_JUMP_SLOT   getchar
0804a00c R_386_JUMP_SLOT   fgets
0804a010 R_386_JUMP_SLOT   __stack_chk_fail
0804a014 R_386_JUMP_SLOT   puts
0804a018 R_386_JUMP_SLOT   __gmon_start__
0804a01c R_386_JUMP_SLOT   __libc_start_main
0804a020 R_386_JUMP_SLOT   memset
0804a024 R_386_JUMP_SLOT   __isoc99_scanf

> ./level07
----------------------------------------------------
  Welcome to wil's crappy number storage service!
----------------------------------------------------
 Commands:
    store - store a number into the data storage
    read  - read a number from the data storage
    quit  - exit the program
----------------------------------------------------
   wil has reserved some storage :>
----------------------------------------------------


# We have a prog that loop and wait for command, the first is store
Input command: store
 Number: 1
 Index: 1
 Completed store command successfully
 
Input command: store
 Number: 0
 Index: 123
 *** ERROR! ***
   This index is reserved for wil!
 *** ERROR! ***
 Failed to do store command
 
# The Number and Index are get with scanf %u, so no negative -1 become 4294967295
# Read functionne the same way and we are allowed to acces wil index, [0]
# We have other index reserved for index % 3 == 0



 804864c:	e8 1f fe ff ff       	call   8048470 <printf@plt>
 8048651:	e8 91 ff ff ff       	call   80485e7 <get_unum>
 8048656:	89 45 f0             	mov    %eax,-0x10(%ebp)         # Where number is stored


 8048666:	e8 7c ff ff ff       	call   80485e7 <get_unum>
 804866b:	89 45 f4             	mov    %eax,-0xc(%ebp)          # Where index is stored
 804866e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
 8048671:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
 8048676:	89 c8                	mov    %ecx,%eax
 8048678:	f7 e2                	mul    %edx
 804867a:	d1 ea                	shr    %edx
 804867c:	89 d0                	mov    %edx,%eax
 804867e:	01 c0                	add    %eax,%eax
 8048680:	01 d0                	add    %edx,%eax# 
 8048682:	89 ca                	mov    %ecx,%edx
 8048684:	29 c2                	sub    %eax,%edx
 8048686:	85 d2                	test   %edx,%edx
 8048688:	74 0d                	je     8048697 <store_number+0x67>

# Check if index % 3 == 0 and jump to error return
https://stackoverflow.com/questions/44212301/efficient-mod-3-in-x86-assembly

# Ok so we know we can store data as unsigned int (4 bytes) in this array and that some value are inaccessible (n % 3 == 0), we can't use env_var,
there is no buffer we can directly overflow, no weak printf nor function, no call of `/bin/sh`
# That mean we have to find a way the store shellcode somewhere and exec it, luckily we have an array that store u_int for us
# Sure, sure but when can we force the stack to exec the code ?
